package CTXEngine.Graphics.GL;

import CTXEngine.Graphics.BufferObject.IndexBufferObject;

import static CTXEngine.Core.CAndCppOperations.*;
import static CTXEngine.Core.SimplePrint.*;
import static CTXEngine.Core.CoreBase.*;
import static org.lwjgl.opengl.GL30.*; //temp

import org.lwjgl.system.NativeType;

/**
 * A index buffer object (Ibo) is an OpenGL feature that provides methods
 * for uploading vertex connection data ( indices ) to the
 * video device for non-immediate-mode rendering.
 */
public class GLIndexBufferObject extends IndexBufferObject
{
	/**@NativeType ("BufferData")
	 *  This is data currently be stored into this index buffer.*/
	private int[] data;
	/**@NativeType ("IndexCount")
	 * This is count of data elements of index buffer.*/
	private int count;
	/**Thats means if count already calculated (size) or not just count (count)*/
	private int countAlreadyCalc; //temp
	/**This is basically id for current index buffer.*/
    private int[] id;
	/**This means how be used this index buffer.*/
	private int usage;
	/*Check if this buffer is created / generated by open gl.*/
	private boolean created = false;
	/**Check if this buffer is bound / selected by open gl and can be used.*/
	protected boolean selected = false;
	
	/**
	 * Creating index buffer object with data and size. Size its
	 * basically size of this input data in bytes of memory.
	 */
	public GLIndexBufferObject(@NativeType("BufferData") int[] dataIn,
							   @NativeType("IndexCount") int countIn)
	{
		this.data = dataIn;
		this.count = countIn;
		this.usage = GL_STATIC_DRAW;
		this.create();
		this.putData();
	}
	
	/**
	 * Creating index buffer object with data and size. Size its
	 * basically size of this input data in bytes of memory.
	 */
	public GLIndexBufferObject(@NativeType("BufferData") int[] dataIn,
							   @NativeType("IndexCount") int countIn, int countAlreadyCalc)
	{
		this.data = dataIn;
		this.count = countIn;
		this.usage = GL_STATIC_DRAW;
		this.countAlreadyCalc = countAlreadyCalc;
		this.create();
		this.putData();
	}
	
	/**
	 * Delete n buffer names in vertexArrayId.
	 */
	@Override
	public void destroyIndexBufferObject()
	{
		this.destroy();
	}
	
	/**
	 * Creates index buffer id's.
	 */
	@Override
	public void create()
	{
		if (!this.created)
		{
			this.id = GLHelper.hglCreateBuffers(1, this.id);
			this.bind();
			this.created = true;
		}
		else
		{
			CTX_ENGINE_ERROR("Index Buffer is already created from this reference." +
				"If your want to re-create buffer, use destroy() and then create()."); System.exit(-1);
		}
	}
	
	/**
	 * Deletes index buffer id's.
	 */
	@Override
	public void destroy()
	{
		if (this.created)
		{
			this.unBind();
			GLHelper.hglDeleteBuffers(1, this.id);
			this.created = false;
		}
		else
		{
			CTX_ENGINE_ERROR("Index Buffer is not created from this reference." +
				"Use create() to create array."); System.exit(-1);
		}
	}
	
	/**
		Bind the current index buffer, to begin use.
	 */
	@Override
	public void bind()
	{
		if (!this.isSelected())
		{
			GLHelper.hglBindBuffer(this.getType(), this.getId());
			this.selected = true;
		}
	}
	
	/**
	 * Bind base the current index buffer, to begin use.
	 */
	public void bindBase(int indexIn)
	{
		GLHelper.hglBindBufferBase(this.getType(), indexIn, this.getId());
	}
	
	/**
	 * Bind range of current index buffer, to end use.
	 */
	public final void bindRange(int indexIn, long offsetIn,
		long sizeIn) 
	{
		GLHelper.hglBindBufferRange(this.getType(), indexIn, this.getId(), offsetIn, sizeIn);
	}
	
	/**
	 * Unbind the current index buffer, to end use.
	 */
	public void unBind()
	{
		if(this.isSelected())
		{
			glBindBuffer(this.getType(), 0);
			this.selected = false;
		}	
	}
	
	/**
	 * Bind base the current index buffer, to begin use.
	 */
	public final void unBindBase(int indexIn)
	{
		glBindBufferBase(this.getType(), indexIn, this.getId());
	}
	
	/**
	 * Unbind range of current vertex buffer, to end use.
	 */
	public final void unBindRange(int indexIn, long offsetIn, long sizeIn) 
	{
		glBindBufferRange(this.getType(), indexIn, 0, offsetIn, sizeIn);
	}
	
	/**
	 * Creates a new data store for the index buffer object currently bound to
	 * target. Any per-existing data store is deleted.
	 */
	@Override
	public void putData()
	{
		if (this.usage == CTX_NULL) this.usage = GL_STATIC_DRAW;
		
		if(this.countAlreadyCalc == 1)
		{
			GLHelper.hglBufferData(this.getType(), this.count,                 this.data, this.usage);
		} else {
			GLHelper.hglBufferData(this.getType(), this.count * sizeof("int"), this.data, this.usage);
		}
	}

	@Override
	public void putData(@NativeType("BufferData") int[] data, @NativeType("IndexCount") int count) 
	{
		
	}
	
	/**
	 * Return the size of data (count).
	 */
	@Override
	public final @NativeType("IndexCount") int getCount()
	{
		return this.count;
	}
	
	/**
	 * Return the size of data (count).
	 */
	@Override
	public final @NativeType("BufferSize") int getSize()
	{
		if(this.countAlreadyCalc == 1)
			return this.count;
		
		return this.count * sizeof("int");
	}
	
	/**
	 * Return the data from this buffer.
	 */
	@Override
	public final @NativeType("BufferData") int[] getData()
	{
		return this.data;
	}
	
	/**
	 * Return the indices from this buffer.
	 */
	@Override
	public final int[] getIndices()
	{
		return this.getData();
	}
	
	/**
	 * Return the id from this buffer.
	 */
	public final int getId()
	{
		return this.id[0];
	}

	@Override
	public boolean isSelected() 
	{
		return this.selected;
	}
	
	/**
	 * Get's the type from this buffer.
	 */
	@Override
	public int getType() 
	{
		return GL_ELEMENT_ARRAY_BUFFER;
	}
}
